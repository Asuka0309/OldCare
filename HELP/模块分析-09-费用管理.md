# 模块分析 09 - 费用管理（答辩速学稿）

面向答辩快速掌握费用管理模块：理解费用的完整生命周期（新增→支付→退款）、多角色操作权限（管理员审批、居民自助支付与申请退款、护工只读）、状态流转与校验规则、前端表单与列表交互。

## 1. 快速索引（必看文件）
- 后端费用控制器：[src/main/java/com/example/oldcaresystem/controller/FeeRecordController.java](oldcare-system/src/main/java/com/example/oldcaresystem/controller/FeeRecordController.java)
- 后端费用实体：[src/main/java/com/example/oldcaresystem/entity/FeeRecord.java](oldcare-system/src/main/java/com/example/oldcaresystem/entity/FeeRecord.java)
- 后端费用服务：[src/main/java/com/example/oldcaresystem/service/FeeRecordService.java](oldcare-system/src/main/java/com/example/oldcaresystem/service/FeeRecordService.java)
- 前端 API 封装：[src/api/feeRecord.js](oldcare-system-front/src/api/feeRecord.js)
- 前端页面：[src/views/FeeRecordView.vue](oldcare-system-front/src/views/FeeRecordView.vue)

## 2. 数据模型与表
- `fee_records`：
  - id（主键自增）
  - appointment_id：关联预约，外键指向 appointments(id)
  - resident_id：居民 ID，统一为 users.id（新数据）；兼容旧数据 elderlyId（elderly_info.id）
  - service_name：服务名称（冗余字段，便于显示）
  - amount：费用金额（BigDecimal，精确到分）
  - fee_type：费用类型（service 服务费 / materials 材料费 / other 其他）
  - status：支付状态（未支付 / 已支付 / 退款申请中 / 已退款）
  - due_date：应付日期（可选）
  - payment_time：支付时间（已支付状态时填充）
  - refund_time：退款时间（已退款状态时填充）
  - remark：备注
  - created_time / updated_time：创建/更新时间

## 3. 费用状态流转与转换规则
```
未支付
  ├─→ 已支付（通过支付接口）
  └─→ 退款申请中（通过申请退款接口，仅限已支付状态）

已支付
  └─→ 退款申请中（通过申请退款接口）

退款申请中
  ├─→ 已退款（管理员同意退款）
  └─→ 已支付（管理员拒绝退款）

已退款（终态，不可逆）
```
**关键点：**
- 已退款状态的费用记录不能再进行任何支付或退款操作。
- 状态转换必须经过对应的接口，不能跳转。

## 4. 后端接口与业务流程

### 4.1 新增费用记录
```
POST /api/fee-record
权限：仅 admin
请求体：{ appointmentId, residentId, amount, serviceName?, feeType?, remark? }

业务规则：
- appointmentId 必填，必须指向一条存在的预约
- residentId 必填，必须指向一个存在的用户
- amount 必填，必须 > 0
- 状态自动初始化为"未支付"
- created_time / updated_time 自动设置为当前时间

返回：201 Created，返回新建的 FeeRecord 对象
```

### 4.2 支付费用（管理员审批）
```
PUT /api/fee-record/{id}/pay
权限：仅 admin
请求体：无

前置校验：
- 费用记录必须存在
- 当前状态必须为"未支付"
- 如果关联了 appointment_id，对应预约必须为"已完成"状态

操作：
- 状态改为"已支付"
- 设置 payment_time = 当前时间
- 更新 updated_time

返回：200 OK，{ code: 0, message: "支付成功" }
```

### 4.3 自助支付（居民）
```
PUT /api/fee-record/{id}/pay-self
权限：resident（仅能支付自己的）
请求体：无

前置校验：
- 费用记录必须存在
- 当前状态必须为"未支付"
- resident_id 必须等于当前登录用户的 id（所有权校验）
- 如果关联了 appointment_id，对应预约必须为"已完成"或"已取消"状态

操作：
- 状态改为"已支付"
- 设置 payment_time = 当前时间
- 更新 updated_time

返回：200 OK，{ code: 0, message: "支付成功" }

差异于 /pay：
- 所有权强制校验（resident_id = userId）
- 允许预约为"已取消"状态也能支付（完整取消后的费用结清）
```

### 4.4 申请退款（居民）
```
PUT /api/fee-record/{id}/refund
权限：resident（仅能申请自己的）
请求体：无

前置校验：
- 费用记录必须存在
- 当前状态必须为"已支付"（只能对已支付的费用申请退款）
- resident_id 必须等于当前登录用户的 id（所有权校验）
- admin 和 caregiver 不可申请退款（返回 403）
- 如果关联了 appointment_id，预约状态必须为"已完成"或"已取消"

操作：
- 状态改为"退款申请中"
- updated_time = 当前时间

返回：200 OK，{ code: 0, message: "退款申请已提交，等待管理员审批" }
```

### 4.5 审批退款（管理员）
```
PUT /api/fee-record/{id}/approve-refund
权限：仅 admin
请求体：{ approved: true/false }

前置校验：
- 费用记录必须存在
- 当前状态必须为"退款申请中"（只能审批处于申请中状态的退款）

操作（approved=true，同意退款）：
- 状态改为"已退款"
- 设置 refund_time = 当前时间
- 更新 updated_time

操作（approved=false，拒绝退款）：
- 状态改为"已支付"（恢复之前的已支付状态）
- 更新 updated_time

返回：200 OK
- 同意：{ code: 0, message: "退款审批通过，退款成功" }
- 拒绝：{ code: 0, message: "退款申请已拒绝，费用记录恢复为已支付状态" }
```

### 4.6 查询费用记录（分页）
```
GET /api/fee-record
权限：admin（全部）、caregiver（只读）、resident（仅自己的）
查询参数：current, size, residentId?, status?

业务规则：
- admin：无条件限制，可查看所有费用记录；可按 residentId、status 过滤
- caregiver：可查看所有费用记录，但为只读（无支付、退款、审批权限）
- resident：只能查看 resident_id = userId 的费用记录；无法通过 residentId 参数查询他人

返回：分页数据
{
  records: [
    {
      id, appointmentId, residentId, residentName, serviceName, amount,
      feeType, status, paymentTime, refundTime, createdTime, updatedTime
    }
  ],
  total, current, size, pages
}
```

### 4.7 查询指定居民的费用
```
GET /api/fee-record/by-resident/{residentId}
权限：admin（全部）、resident（仅自己）
查询参数：current, size

业务规则：
- admin：可查看任意居民的费用
- resident：只能查看自己的费用（residentId 必须 = userId）

返回：分页数据
```

## 5. 前端交互与流程

### 5.1 费用记录列表（FeeRecordView.vue）
- **筛选区：**
  - 按居民选择：下拉菜单（加载所有老人信息），可清空
  - 按状态选择：下拉菜单（未支付 / 已支付 / 退款申请中 / 已退款），可清空

- **表格展示：**
  - 列：ID、预约 ID、服务名、居民名、金额、费用类型、状态（Tag 标签）、支付时间、创建时间、操作
  - 状态 Tag 样式：未支付（default）、已支付（success）、退款申请中（warning）、已退款（info）

- **操作按钮（按角色与状态展示）：**
  - Admin 可见：
    - 支付按钮：状态 = 未支付 时显示，点击调用 payFeeRecord(id)
    - 同意退款：状态 = 退款申请中 时显示，点击确认后调用 approveRefundApi(id, true)
    - 拒绝退款：状态 = 退款申请中 时显示，点击确认后调用 approveRefundApi(id, false)
  
  - Resident 可见：
    - 支付按钮：状态 = 未支付 && 是本人记录 时显示，点击调用 paySelfFeeRecord(id)
    - 申请退款：状态 = 已支付 && 是本人记录 时显示，点击确认后调用 refundFeeRecord(id)
  
  - Caregiver：无操作按钮（仅查看）

- **分页与刷新：**
  - 分页器：显示 total、current、size，支持快速跳转
  - 刷新按钮：手动刷新列表

### 5.2 新增费用对话框（Admin only）
- 触发：Admin 可见"新增费用"按钮，点击打开对话框
- 表单字段：
  - 预约 ID（input-number）：必填，验证 > 0
  - 居民（select）：必填，从 elderlyOptions 列表选择
  - 金额（input-number）：必填，验证 > 0，步长 0.01
  - 备注（textarea）：可选
- 提示信息：建议通过完成服务预约来自动生成费用，手动添加仅用于特殊情况
- 提交逻辑：表单验证通过后调用 createFeeRecord(formData)，成功后关闭对话框并刷新列表

### 5.3 关键的前端逻辑
```javascript
// 检查是否本人费用记录
function isOwnRecord(row) {
  const uid = currentUserId.value
  return [row.residentId, row.elderlyId, row.userId]
    .some(v => String(v) === String(uid))
}

// 支付权限判断
function canPay(row) {
  const status = row.status?.trim()
  if (status !== '未支付') return false
  if (isAdmin.value) return true
  if (isResident.value && isOwnRecord(row)) return true
  return false
}

// 申请退款权限判断
function canRefund(row) {
  if (!isResident.value) return false
  return isOwnRecord(row) && row.status === '已支付'
}

// 居民名查询（兼容两种数据格式）
function findName(id) {
  const elderly = elderlyOptions.value.find(e => e.id === id)
  if (elderly) return elderly.name
  
  const user = userOptions.value.find(u => u.id === id)
  if (user) return user.real_name || user.name
  
  return '-'
}
```

## 6. 角色与权限矩阵

| 操作 | Admin | Caregiver | Resident |
|------|-------|-----------|----------|
| 新增费用（手动） | ✓ | ✗ | ✗ |
| 查看所有费用 | ✓ | ✓（只读） | ✗ |
| 查看自己的费用 | ✓ | ✓ | ✓ |
| 支付费用（管理员审批） | ✓ | ✗ | ✗ |
| 自助支付 | ✗ | ✗ | ✓（自己的） |
| 申请退款 | ✗ | ✗ | ✓（自己的） |
| 审批退款 | ✓ | ✗ | ✗ |

## 7. 答辩常见问答（含实现思路）

**Q: 为什么费用必须关联预约？**
A: 费用来自已完成的服务预约，通过 appointment_id 外键追溯服务内容、服务方与接收方身份，支持费用→预约→服务的完整链路，便于核对与审计。

**Q: Admin 支付与 Resident 自助支付的区别是什么？**
A: Admin 支付（/pay）用于管理员审批后统一支付，无需额外预约校验；Resident 自助支付（/pay-self）用户自主结算，强制校验所有权与预约状态（允许已取消）。

**Q: 如何防止护工修改费用？**
A: 在 FeeRecordController 所有修改接口（支付、退款、审批）中校验当前用户的角色，caregiver 返回 403；前端也不显示操作按钮。

**Q: 申请退款后能取消吗？**
A: 当前设计不支持在"退款申请中"状态下再次操作；需要管理员同意或拒绝。若要支持取消，可增加新接口或在前端加"撤销申请"按钮。

**Q: 如何处理新旧 resident_id 的兼容性？**
A: 费用表中 resident_id 统一存 users.id（新系统）；旧数据可能是 elderly_info.id；前端查询名字时同时加载 elderlyOptions 和 userOptions，通过 findName() 依次查找，确保兼容。

**Q: 支付失败（如余额不足）怎么办？**
A: 当前接口仅改数据库状态，实际支付由第三方网关（如支付宝、微信）处理；若需集成，可增加 paymentMethod、transactionId 等字段，接口返回支付链接而非直接改状态。

**Q: 审批退款时，拒绝后费用会恢复为"已支付"吗？**
A: 是的，approve-refund 中拒绝退款（approved=false）会将状态从"退款申请中"改为"已支付"，费用记录保留在系统中。

**Q: 多次申请退款会导致什么问题？**
A: 当前设计中，已退款（已退款）状态的费用无法再申请退款，避免重复申请；若为"已支付"状态，可再次申请。建议前端在已退款状态下隐藏"申请退款"按钮。

**Q: 如何实现"审批后自动通知居民"？**
A: 可在 approve-refund 接口中增加消息推送逻辑，调用 NotificationService 创建通知记录；前端定时轮询或 WebSocket 监听通知列表，实时显示审批结果。

**Q: 费用金额支持部分退款吗？**
A: 当前设计为全额退款；若要部分退款，可增加字段 refund_amount，同时保留 amount 为原额；或创建新的退款记录（amount 为负数）表示部分冲减。

## 8. 改进建议（答辩加分点）
- **权限细化**：在网关或 AOP 处统一校验角色与资源所有权，避免重复判断。
- **数据一致性**：统一 resident_id 数据格式，编写迁移脚本将旧 elderlyId 转为 users.id。
- **异常处理**：对网络超时、数据库异常进行重试与回滚，支付操作支持幂等性（使用唯一订单号）。
- **支付集成**：集成真实支付网关（支付宝、微信），支持支付状态回调与对账。
- **财务对账**：增加对账单功能，定期核对待支付与已支付费用；支持导出为 Excel/PDF。
- **审计日志**：记录所有费用操作（新增、支付、退款）的操作者、时间、原因，支持查询。
- **提醒与催收**：对逾期未支付费用发送催收通知；预警即将过期的退款申请（如 7 天无审批）。
- **分期支付**：支持大额费用分期付款，灵活安排支付计划。
