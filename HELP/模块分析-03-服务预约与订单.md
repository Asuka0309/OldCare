# 模块分析 03 - 服务预约与订单（答辩速学稿）

覆盖预约创建/确认/完成、费用记录生成与支付退款流程，聚焦接口逻辑、外键约束与前端交互，便于答辩应对。

## 1. 快速索引（需优先阅读的文件）
- 预约核心： [src/main/java/com/example/oldcaresystem/controller/AppointmentController.java](oldcare-system/src/main/java/com/example/oldcaresystem/controller/AppointmentController.java)、[src/main/java/com/example/oldcaresystem/service/AppointmentService.java](oldcare-system/src/main/java/com/example/oldcaresystem/service/AppointmentService.java)、[src/main/java/com/example/oldcaresystem/entity/Appointment.java](oldcare-system/src/main/java/com/example/oldcaresystem/entity/Appointment.java)、[src/main/java/com/example/oldcaresystem/mapper/AppointmentMapper.java](oldcare-system/src/main/java/com/example/oldcaresystem/mapper/AppointmentMapper.java)
- 费用/订单： [src/main/java/com/example/oldcaresystem/entity/FeeRecord.java](oldcare-system/src/main/java/com/example/oldcaresystem/entity/FeeRecord.java)（见同目录）、[src/main/java/com/example/oldcaresystem/service/FeeRecordService.java](oldcare-system/src/main/java/com/example/oldcaresystem/service/FeeRecordService.java)
- 数据库表： appointments、fee_records（见 [src/main/resources/db/oldcare_system.sql](oldcare-system/src/main/resources/db/oldcare_system.sql)，含 status 枚举、外键约束）
- 前端交互： [src/api/appointment.js](oldcare-system-front/src/api/appointment.js)、[src/views/AppointmentView.vue](oldcare-system-front/src/views/AppointmentView.vue)、[src/views/FeeRecordView.vue](oldcare-system-front/src/views/FeeRecordView.vue)
- 关联依赖：服务表 services（价格）、护工 caregivers/users（provider_id 存用户ID）、评价 evaluation、费用 fee_records 外键等。

## 2. 数据模型与表
- appointments：resident_id（users.id）、provider_id（护工 users.id）、service_id、appointment_date、status（待确认/已确认/进行中/已完成/已取消）、total_amount、remark、created_time、updated_time。
- fee_records：appointment_id → appointments.id，resident_id → users.id，service_name、amount、status（未支付/已支付/退款申请中/已退款）、payment_time/refund_time 等。
- 外键：appointments.service_id → services.id；fee_records.appointment_id → appointments.id；完成预约时自动生成费用记录。

## 3. 预约流程（后端）
- 新增 POST /api/appointment：
  - 校验居民存在且角色 resident；校验服务存在；校验必须指定护工。
  - 支持传 caregivers.id 或 users.id，最终存 provider_id 为护工的 users.id。
  - 设置 totalAmount=服务价格，status="待确认"，写入时间戳后保存。
- 修改 PUT /api/appointment：按 id 更新，更新时间戳。
- 取消 PUT /api/appointment/{id}/cancel：status→已取消。
- 确认 PUT /api/appointment/{id}/confirm：status→已确认。
- 完成 PUT /api/appointment/{id}/complete：仅已确认可完成；若未完成则改为已完成，并检查 fee_records 是否存在，不存在则按 service.price 和 resident_id 自动生成费用记录，状态置未支付。
- 删除 DELETE /api/appointment/{id}（管理员）：先删关联 fee_records 与 evaluation 再删预约，避免外键阻塞。

## 4. 预约查询与角色可见性
- GET /api/appointment 分页：
  - admin：可见全部；
  - caregiver：仅 provider_id=本人 users.id；若无绑定护工记录返回空集；
  - resident：仅 resident_id=本人；
  - 可选过滤 residentId、status，按 created_time desc。
- GET /api/appointment/{id}：单条。
- GET /api/appointment/resident/{residentId}：按居民。
- GET /api/appointment/caregiver/{caregiverId}：路径用 caregivers.id，内部转换为 users.id 匹配 provider_id。

## 5. 费用/订单流程（前后端协同）
- 费用生成：完成预约接口自动生成 fee_records（未支付）；已存在则不重复。
- 前端 FeeRecordView：列表筛选、支付、退款申请、管理员审批退款；支付支持管理员代付或居民自付。
- 状态衍生：AppointmentView 在渲染时优先用费用状态（已退款/退款申请中/已支付），再回退预约状态。
- 支付与退款 API（feeRecord.js，不在此列出代码）：payFeeRecord/paySelfFeeRecord、refundFeeRecord、approveRefund；前端按钮显示依据角色与状态。

## 6. 前端预约交互（AppointmentView.vue）
- 搜索筛选：按老人（residentId=users.id）、状态筛选；非护工可新建预约。
- 表单：选择老人/护工/服务、预约时间；选服务时同步价格为 totalAmount；状态可选但新建默认待确认。
- 权限按钮：
  - 护工视角：无“新建”，仅查看和被分配的预约。
  - 完成按钮：service_provider 或 caregiver 可见，状态需已确认。
  - 取消：非已取消/已完成都可取消。
  - 删除：仅管理员。
- 费用状态融合：前端在 load 时拉取 fee_records，将预约状态覆写展示以反映支付/退款结果。

## 7. 答辩常见问答（含“怎么实现”）
- 问：为什么完成预约会自动生成费用记录？
  - 答：完成后即进入结算阶段，控制器在 complete 中检查 fee_records 不存在时创建，避免重复生成，并填充 serviceName/amount/residentId。
- 问：删除预约前为什么要先删费用和评价？
  - 答：fee_records、evaluations 有外键指向 appointments；先删子表避免外键阻塞，保持数据一致性。
- 问：护工/居民各自能看到哪些预约？
  - 答：通过 UserContext 读取 role 和 userId，caregiver 仅 provider_id=自己；resident 仅 resident_id=自己；admin 不限。
- 问：怎么防止未确认就被完成？
  - 答：complete 接口校验 status 必须是已确认；否则返回 400。
- 问：怎么实现支付和退款流程？
  - 答：支付接口将 fee_records.status 改为已支付并记录支付时间；退款申请由居民触发置“退款申请中”，管理员调用审批接口同意→已退款+退款时间，拒绝→恢复已支付。
- 问：如何处理护工 ID 传法不一致？
  - 答：控制器兼容传 caregivers.id 或 users.id；若按 caregivers.id 找到则取其 user_id，最终 provider_id 存 users.id，保证外键一致。
- 问：为什么删除服务项目时会禁用而非硬删？
  - 答：appointments.service_id 外键引用 services；禁用避免已有预约报错，且历史记录仍可查询。
- 问：怎么扩展预约状态为“进行中”？
  - 答：在控制器添加 start 接口将状态改进行中；前端新增按钮与状态展示；必要时限制 only 已确认→进行中→已完成 的顺序。
- 问：如何防止未支付的预约被重复支付？
  - 答：前端按钮基于状态过滤；后端支付接口需检查当前状态，只允许未支付/待支付转已支付，已退款/退款申请中拒绝。

## 8. 改进建议（答辩可提）
- 并发与幂等：complete、pay、refund 增加乐观锁或状态机校验，避免重复操作。
- 余额/支付网关：接入真实支付网关或虚拟钱包，记录 transaction_id；支付/退款写审计日志。
- 日程冲突：新增校验同一护工/居民在时间段内的预约冲突。
- 通知与提醒：完成、取消、退款等事件触发通知（短信/站内信）。
- 数据校验：金额为服务价格，不允许前端随意改；预约时间需晚于当前时间。
