# 模块文件映射-09-费用管理

> 范围：费用记录的查询、手动创建（管理员）、支付标记（管理员）、退款申请（居民）、退款审批（管理员）。
> 关键点：权限严格在后端 Controller 校验；同时兼容 `resident_id` 两种口径（`users.id` / `elderly_info.id`）。

---

## 1. 前端文件（oldcare-system-front）

### 1.1 路由入口
- 路由定义：[oldcare-system-front/src/router/index.js](oldcare-system-front/src/router/index.js)
  - 费用管理页面：`/fees` → `FeeRecordView.vue`
  - 允许角色：`admin`、`resident`、`caregiver`

### 1.2 页面实现
- 页面：[oldcare-system-front/src/views/FeeRecordView.vue](oldcare-system-front/src/views/FeeRecordView.vue)
  - 筛选：
    - 按居民筛选：`query.residentId`（下拉数据源来自 `elderlyOptions`）
    - 按状态筛选：`未支付/已支付/退款申请中/已退款`
  - 表格字段：费用ID、预约ID、服务名称、居民、金额、状态、支付时间、创建时间
  - 操作按钮（按角色与状态显示）：
    - 管理员：
      - `未支付` → “标记支付”
      - `退款申请中` → “同意退款/拒绝退款"
    - 居民：
      - `已支付` 且 `canRefund(row)` → “申请退款"
    - 护工：只读，不显示操作
  - 重要实现细节：
    - 页面初始化并行加载：
      - `fetchAllElderly()` 拉取老人列表（`elderlyOptions`）
      - `fetchUsers({ role:'resident', size:999 })` 拉取居民用户列表（`userOptions`）
    - 展示姓名优先使用后端返回的 `residentName`，否则走本地 `findName(id)` 兼容查找（elderly_info / users / elderly_info.user_id 映射）

### 1.3 API 封装
- 费用 API：[oldcare-system-front/src/api/feeRecord.js](oldcare-system-front/src/api/feeRecord.js)
  - `fetchFeeRecords(params)` → `GET /api/fee-record`
  - `createFeeRecord(data)` → `POST /api/fee-record`（管理员）
  - `getFeeRecordById(id)` → `GET /api/fee-record/{id}`
  - `getFeeRecordsByResident(residentId, params)` → `GET /api/fee-record/by-resident/{residentId}`
  - `payFeeRecord(id)` → `PUT /api/fee-record/{id}/pay`（管理员）
  - `refundFeeRecord(id)` → `PUT /api/fee-record/{id}/refund`（居民本人）
  - `approveRefund(id, approved)` → `PUT /api/fee-record/{id}/approve-refund`（管理员）

- 老人/用户数据源（用于筛选与姓名兼容显示）：
  - [oldcare-system-front/src/api/elderly.js](oldcare-system-front/src/api/elderly.js)
  - [oldcare-system-front/src/api/user.js](oldcare-system-front/src/api/user.js)

---

## 2. 后端文件（oldcare-system）

### 2.1 Controller
- 费用记录控制器：[oldcare-system/src/main/java/com/example/oldcaresystem/controller/FeeRecordController.java](oldcare-system/src/main/java/com/example/oldcaresystem/controller/FeeRecordController.java)
  - 基路径：`/api/fee-record`

### 2.2 Entity / Service / Mapper
- 费用记录：
  - 实体：[oldcare-system/src/main/java/com/example/oldcaresystem/entity/FeeRecord.java](oldcare-system/src/main/java/com/example/oldcaresystem/entity/FeeRecord.java)
  - 服务：[oldcare-system/src/main/java/com/example/oldcaresystem/service/FeeRecordService.java](oldcare-system/src/main/java/com/example/oldcaresystem/service/FeeRecordService.java)
  - Mapper：[oldcare-system/src/main/java/com/example/oldcaresystem/mapper/FeeRecordMapper.java](oldcare-system/src/main/java/com/example/oldcaresystem/mapper/FeeRecordMapper.java)

- 依赖（校验与双口径映射用）：
  - 预约：`AppointmentService`（支付/退款时校验预约状态）
  - 老人：`ElderlyInfoService`（本人校验、elderlyId/residentName 填充）
  - 用户：`UserService`（residentName 填充）

---

## 3. 接口映射（前端调用 ↔ 后端实现）

### 3.1 新增费用记录（手动创建）
- `POST /api/fee-record`
  - 前端：`createFeeRecord({ appointmentId, residentId, amount, ... })`
  - 后端：`FeeRecordController.add(feeRecord)`
  - 权限：仅 `admin`
  - 校验：
    - `appointmentId` 必填
    - `residentId` 必填（兼容接收 `elderlyId` 并归一到 `residentId`）
    - `amount > 0`
  - 初始化：
    - `status = '未支付'`
    - `createdTime/updatedTime = now`

### 3.2 标记支付（审批确认）
- `PUT /api/fee-record/{id}/pay`
  - 前端：`payFeeRecord(id)`
  - 后端：`FeeRecordController.pay(id)`
  - 权限：仅 `admin`
  - 状态约束：
    - 已支付/已退款/退款申请中 → 拒绝
    - 如有关联预约：必须 `appointment.status == '已完成'`
  - 更新：
    - `status = '已支付'`
    - `paymentTime = now`

### 3.3 申请退款（居民本人）
- `PUT /api/fee-record/{id}/refund`
  - 前端：`refundFeeRecord(id)`
  - 后端：`FeeRecordController.refund(id)`
  - 权限：仅 `resident`（管理员/护工会被 403）
  - 状态约束：只能对 `已支付` 申请；`已退款/退款申请中/未支付` → 拒绝
  - 本人校验（后端三路径，兼容历史数据）：
    1) `fee_records.resident_id == currentUserId`（resident_id 存 users.id）
    2) `fee_records.resident_id` 作为 `elderly_info.id`，并且 `elderly_info.user_id == currentUserId`
    3) `feeRecord.elderlyId`（兼容字段）按同样方式校验
  - 预约状态校验：
    - 如果关联预约且预约存在：只允许 `已完成` 或 `已取消` 申请退款
  - 更新：`status = '退款申请中'`

### 3.4 审批退款（管理员）
- `PUT /api/fee-record/{id}/approve-refund`，Body：`{ approved: boolean }`
  - 前端：`approveRefund(id, true/false)`
  - 后端：`FeeRecordController.approveRefund(id, request)`
  - 权限：仅 `admin`
  - 约束：必须是 `退款申请中`
  - 结果：
    - `approved=true` → `status='已退款'` + `refundTime=now`
    - `approved=false` → `status='已支付'`

### 3.5 查询：按居民分页
- `GET /api/fee-record/by-resident/{residentId}?current=1&size=10`
  - 前端：`getFeeRecordsByResident(residentId, params)`（当前页面主要用通用分页接口 `GET /api/fee-record`）
  - 后端：`FeeRecordController.getFeeRecordsByResidentId(residentId, current, size)`
  - 返回增强：对 records 调用 `setElderlyIdForRecords()` 填充 `elderlyId/residentName`

### 3.6 查询：通用分页（带数据隔离）
- `GET /api/fee-record?current=1&size=10&residentId=&status=`
  - 前端：`fetchFeeRecords(query)`
  - 后端：`FeeRecordController.list(current, size, residentId, status)`
  - 角色逻辑：
    - `resident`：只返回本人费用（同时匹配 `users.id` 与其关联的 `elderly_info.id` 列表）
    - `admin/caregiver`：可查看全量并支持筛选
  - 返回增强：对 records 调用 `setElderlyIdForRecords()` 填充 `elderlyId/residentName`

### 3.7 查询：单条
- `GET /api/fee-record/{id}`
  - 前端：`getFeeRecordById(id)`
  - 后端：`FeeRecordController.getById(id)`（同样会填充 `elderlyId/residentName`）

---

## 4. 双口径 residentId 兼容（后端核心逻辑）

- 费用表字段：`fee_records.resident_id` 可能存：
  - 新数据：`users.id`
  - 旧数据：`elderly_info.id`

- 后端展示兼容（`setElderlyIdForRecords`）：
  - 若 `resident_id` 能在 `users` 查到：
    - `residentName = user.realName`（为空则尝试用 `elderly_info.name`）
    - `elderlyId = elderly_info.id`（通过 `elderly_info.user_id = resident_id`）
  - 否则把 `resident_id` 当作 `elderly_info.id`：
    - `residentName = elderly_info.name`（若能反查到 user.realName，则用 realName 覆盖）
    - `elderlyId = elderly_info.id`

---

## 5. 数据表（db/oldcare_system.sql）

- `fee_records`
  - 核心字段：`appointment_id/resident_id/service_name/amount/status/payment_time/refund_time/created_time/updated_time`
  - SQL 默认状态：`未支付`；已存在数据含 `已支付/已退款`
  - 代码业务状态还包括：`退款申请中`

---

## 6. 联调/差异点提示（建议关注）

- 前端 `canRefund(row)` 判定偏简化：
  - 当前实现是 `row.residentId === currentUserId || row.elderlyId === currentUserId`。
  - 若历史数据 `residentId` 存的是 `elderly_info.id`，则 `elderlyId` 也会是 `elderly_info.id`，通常不等于 `users.id`，可能导致“后端允许退款但前端按钮不显示”。

- 前端“按居民筛选”的下拉值来源：
  - 下拉的 `value` 取自 `elderlyOptions.id`（elderly_info.id）。
  - 若某些费用记录的 `resident_id` 存的是 `users.id`，直接传 `residentId=elderly_info.id` 可能筛不到对应记录（需要依赖后端返回的 `elderlyId` 做筛选，或改造筛选参数口径）。

- `GET /by-resident/{residentId}` 的权限：
  - 该方法当前未做角色/本人校验（与 `GET /api/fee-record` 的 resident 隔离逻辑不一致）。
  - 如要严格符合“居民只能看本人”的设计，需要在该接口补充相同的权限/本人校验。
