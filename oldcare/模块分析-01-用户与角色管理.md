# 用户与角色管理模块 - 详细分析

## 📌 模块概述

**模块名称**：用户与角色管理  
**核心功能**：用户注册、登录、管理和权限控制  
**适用角色**：系统管理员（增删改查）、所有用户（登录/注册）  
**关键特性**：JWT认证、角色权限控制、多标签页独立登录

---

## 🎯 核心功能

### 1. 用户认证（Authentication）

#### 1.1 用户登录
```
前端页面：LoginView.vue
后端接口：POST /api/auth/login
请求参数：{ username, password }
返回数据：{ token, userId, username, role, realName }

流程：
1. 用户输入用户名和密码
2. 前端校验（非空、长度检查）
3. 发送登录请求到后端
4. 后端验证用户和密码（MD5加密对比）
5. 验证成功生成JWT Token
6. 前端保存Token到sessionStorage
7. 设置Axios请求头Authorization
8. 重定向到主页面
```

**代码示例（前端）**：
```javascript
// LoginView.vue
const onSubmit = async () => {
  await auth.login({
    username: form.username,
    password: form.password
  })
  // 保存到sessionStorage
  router.push('/dashboard')
}
```

**代码示例（后端）**：
```java
@PostMapping("/login")
public ResponseUtil<LoginResponse> login(@RequestBody LoginRequest request) {
  LoginResponse response = userService.login(request);
  // 生成JWT Token
  // 验证密码（MD5加密）
  // 返回用户信息和Token
  return ResponseUtil.success("登录成功", response);
}
```

#### 1.2 Token管理
- **存储位置**：sessionStorage（支持多标签页独立登录）
- **Token格式**：JWT (JSON Web Token)
- **Token获取**：登录成功后返回
- **Token使用**：每次请求的Authorization头中

**代码示例（存储）**：
```javascript
// auth.js store
async login(payload) {
  const data = await loginApi(payload)
  this.token = data.token
  this.user = { ...userData }
  // 存储到sessionStorage而非localStorage
  sessionStorage.setItem(TOKEN_KEY, this.token)
  sessionStorage.setItem(USER_KEY, JSON.stringify(this.user))
}
```

**代码示例（使用）**：
```javascript
// http.js interceptor
instance.interceptors.request.use((config) => {
  const auth = useAuthStore()
  if (auth.token) {
    config.headers.Authorization = `Bearer ${auth.token}`
  }
  return config
})
```

### 2. 用户注册

#### 2.1 居民注册
**页面**：RegisterView.vue  
**角色**：resident（社区居民）  
**必填字段**：
- 用户名（唯一性检查）
- 密码（至少6位）
- 确认密码（需要匹配）
- 真实姓名
- 电话

**可选字段**：无

**业务逻辑**：
1. 验证用户名不为空且唯一
2. 验证密码符合要求（≥6位）
3. 验证两次密码一致
4. 使用MD5加密密码
5. 创建用户记录
6. 设置默认角色为 `resident`
7. 设置状态为激活（status=1）
8. 自动生成创建时间

#### 2.2 护工注册
**角色**：caregiver（社区护工）  
**必填字段**（同居民）：
- 用户名
- 密码
- 真实姓名
- 电话

**可选字段**：
- 工作单位（companyName）

**业务逻辑**：同居民，额外保存工作单位信息

**代码示例（前端）**：
```vue
<el-radio-group v-model="form.role">
  <el-radio value="resident">社区居民</el-radio>
  <el-radio value="caregiver">社区护工</el-radio>
</el-radio-group>

<!-- 护工特定字段 -->
<el-form-item v-if="form.role === 'caregiver'" label="工作单位（可选）">
  <el-input v-model="form.companyName" />
</el-form-item>
```

**代码示例（后端）**：
```java
@PostMapping("/register")
public ApiResponse<?> register(@RequestBody Map<String, Object> requestBody) {
  String username = (String) requestBody.get("username");
  String password = (String) requestBody.get("password");
  String role = (String) requestBody.get("role");
  String companyName = (String) requestBody.get("companyName");
  
  // 1. 验证用户名唯一性
  User existing = userService.lambdaQuery()
    .eq(User::getUsername, username)
    .one();
  if (existing != null) {
    return ApiResponse.error(400, "用户名已存在");
  }
  
  // 2. 创建用户
  User user = new User();
  user.setUsername(username);
  user.setPassword(MD5Util.encrypt(password));  // MD5加密
  user.setRole(role);
  user.setStatus(1);  // 激活状态
  user.setCreatedTime(LocalDateTime.now());
  
  userService.save(user);
  return ApiResponse.success("注册成功");
}
```

#### 2.3 管理员添加用户
**权限**：仅管理员  
**操作方式**：通过用户管理页面新增  
**可选角色**：
- admin（管理员）
- caregiver（护工）
- elderly_family（老人家属）
- system（系统用户）

---

## 🔐 权限与角色管理

### 1. 角色定义

| 角色 | 标识 | 说明 | 用户级别 |
|------|------|------|---------|
| 系统管理员 | admin | 系统最高权限，全局管理 | 内部 |
| 护工 | caregiver | 提供服务，执行预约 | 内部 |
| 居民 | resident | 预约服务，申请退款 | 外部 |
| 老人家属 | elderly_family | 可配置但实际未使用 | 外部 |
| 系统用户 | system | 可配置但实际未使用 | 内部 |

### 2. 权限矩阵

#### 2.1 功能模块权限

| 功能 | admin | caregiver | resident | elderly_family |
|------|-------|-----------|----------|------------------|
| 用户管理（CRUD） | ✅ | ❌ | ❌ | ❌ |
| 查看所有用户 | ✅ | ❌ | ❌ | ❌ |
| 禁用/启用用户 | ✅ | ❌ | ❌ | ❌ |
| 删除用户 | ✅ | ❌ | ❌ | ❌ |
| 修改自己信息 | ✅ | ✅ | ✅ | ✅ |

#### 2.2 跨模块权限

```
预约管理：
- admin: 增删改查、审批、删除
- caregiver: 查看、确认、完成
- resident: 创建（自己）、查看（自己）

费用管理：
- admin: 增删改查、标记支付、审批退款
- caregiver: 仅查看（读权限）
- resident: 查看（自己）、申请退款（自己）

健康管理：
- admin: 查看所有、增删改
- caregiver: 查看、新增记录
- resident: 查看自己

其他模块：
- admin: 完全权限
- caregiver: 查看权限
- resident: 查看权限
```

### 3. 权限实现方式

#### 3.1 前端权限控制
```javascript
// auth.js store
const isAdmin = computed(() => role.value === 'admin')
const isCaregiver = computed(() => role.value === 'caregiver')
const isResident = computed(() => role.value === 'resident')

// 在模板中使用
<el-button v-if="isAdmin" @click="handleAdmin">管理员操作</el-button>
<el-button v-if="isResident && isOwnRecord" @click="handleResident">我的操作</el-button>
```

#### 3.2 后端权限控制
```java
// UserContext 获取当前用户信息
String role = UserContext.getRole();
Long userId = UserContext.getUserId();

// 权限检查
if (!"admin".equalsIgnoreCase(role)) {
  return ApiResponse.error(403, "无权限操作");
}

// 数据隔离
if (isResident && !record.getResidentId().equals(userId)) {
  return ApiResponse.error(403, "只能查看自己的数据");
}
```

#### 3.3 路由守卫（前端）
```javascript
// router/index.js
router.beforeEach((to, from, next) => {
  const auth = useAuthStore()
  
  // 未登录跳转登录页
  if (!auth.token && to.path !== '/login' && to.path !== '/register') {
    next('/login')
    return
  }
  
  // 已登录不能访问登录/注册页
  if (auth.token && (to.path === '/login' || to.path === '/register')) {
    next('/dashboard')
    return
  }
  
  next()
})
```

---

## 🗄️ 数据模型

### 1. User 表结构

```sql
CREATE TABLE users (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,           -- MD5加密
  real_name VARCHAR(100),
  phone VARCHAR(20),
  role VARCHAR(20) DEFAULT 'resident',      -- admin/caregiver/resident
  status INT DEFAULT 1,                     -- 1: 激活, 0: 禁用
  created_time TIMESTAMP,
  updated_time TIMESTAMP,
  INDEX idx_username (username),
  INDEX idx_role (role),
  INDEX idx_status (status)
);
```

### 2. 字段说明

| 字段 | 类型 | 说明 | 约束 |
|------|------|------|------|
| id | BIGINT | 用户ID | PK, AI |
| username | VARCHAR(50) | 登录用户名 | UNIQUE, NOT NULL |
| password | VARCHAR(255) | MD5加密密码 | NOT NULL |
| real_name | VARCHAR(100) | 真实姓名 | 可空 |
| phone | VARCHAR(20) | 联系电话 | 可空 |
| role | VARCHAR(20) | 用户角色 | DEFAULT: resident |
| status | INT | 账户状态 | 1(激活)/0(禁用) |
| created_time | TIMESTAMP | 创建时间 | 自动赋值 |
| updated_time | TIMESTAMP | 更新时间 | 自动赋值 |

### 3. 关键索引

```sql
INDEX idx_username (username)       -- 加速用户名查询和唯一性检查
INDEX idx_role (role)               -- 加速角色筛选
INDEX idx_status (status)           -- 加速状态筛选
```

---

## 📡 API 接口

### 1. 认证相关

#### 1.1 用户登录
```
POST /api/auth/login
请求体：{
  "username": "admin",
  "password": "admin123"
}

响应：{
  "code": 0,
  "message": "登录成功",
  "data": {
    "token": "eyJhbGc...",           -- JWT Token
    "userId": 1,
    "username": "admin",
    "role": "admin",
    "realName": "管理员"
  }
}
```

#### 1.2 用户注册
```
POST /api/user/register
请求体：{
  "username": "resident001",
  "password": "123456",
  "realName": "王大明",
  "phone": "13800138000",
  "role": "resident",
  "companyName": null                -- 仅护工需要
}

响应：{
  "code": 0,
  "message": "注册成功",
  "data": null
}
```

### 2. 用户管理

#### 2.1 查询用户列表
```
GET /api/user?current=1&size=10&username=admin&role=admin
参数：
  - current: 当前页码（默认1）
  - size: 页大小（默认10）
  - username: 用户名筛选（可选）
  - role: 角色筛选（可选）

响应：{
  "code": 0,
  "message": "成功",
  "data": {
    "records": [
      {
        "id": 1,
        "username": "admin",
        "realName": "管理员",
        "phone": "13800138000",
        "role": "admin",
        "status": 1,
        "createdTime": "2025-12-27 10:00:00"
      }
    ],
    "total": 100,
    "current": 1,
    "size": 10
  }
}
```

#### 2.2 获取用户详情
```
GET /api/user/{id}

响应：{
  "code": 0,
  "message": "成功",
  "data": {
    "id": 1,
    "username": "admin",
    "realName": "管理员",
    "phone": "13800138000",
    "role": "admin",
    "status": 1,
    "createdTime": "2025-12-27 10:00:00"
  }
}
```

#### 2.3 新增用户
```
POST /api/user
请求体：{
  "username": "newuser",
  "password": "123456",
  "realName": "新用户",
  "phone": "13800138001",
  "role": "caregiver",
  "status": 1
}

响应：{
  "code": 0,
  "message": "已创建",
  "data": null
}
```

#### 2.4 修改用户
```
PUT /api/user
请求体：{
  "id": 1,
  "realName": "管理员1",
  "phone": "13800138001",
  "role": "admin",
  "status": 1
}

响应：{
  "code": 0,
  "message": "已更新",
  "data": null
}
```

#### 2.5 更新用户状态
```
PUT /api/user/{id}/status?status=0
参数：status (1: 激活, 0: 禁用)

响应：{
  "code": 0,
  "message": "已更新",
  "data": null
}
```

#### 2.6 删除用户
```
DELETE /api/user/{id}

响应：{
  "code": 0,
  "message": "已删除",
  "data": null
}
```

---

## 🎨 前端页面

### 1. 登录页面（LoginView.vue）

**特点**：
- 白色主题设计
- 简洁清爽的布局
- 默认账号提示（admin/admin123）
- 支持Enter快速登录
- 注册链接跳转

**功能**：
1. 用户名和密码输入
2. 表单验证
3. 登录请求
4. 错误提示
5. 跳转到首页

**验证规则**：
- 用户名：非空
- 密码：非空

### 2. 注册页面（RegisterView.vue）

**特点**：
- 白色卡片设计
- 角色选择（仅居民和护工）
- 动态表单（护工显示工作单位）
- 密码确认检查
- 跳回登录链接

**功能**：
1. 角色选择（resident/caregiver）
2. 基本信息输入
3. 密码和确认密码验证
4. 护工工作单位输入
5. 注册请求
6. 成功跳转登录

**验证规则**：
- 用户名：非空，3-50字符，唯一性检查
- 密码：非空，≥6位
- 确认密码：需与密码一致
- 真实姓名：非空，1-100字符
- 电话：非空，有效格式

### 3. 用户管理页面（UserView.vue）

**特点**：
- 表格展示用户列表
- 搜索和筛选功能
- 批量操作（禁用/启用）
- 用户信息编辑对话框
- 分页查询

**功能**：
1. **查询**：
   - 按用户名搜索
   - 按角色筛选
   - 分页显示

2. **新增**：
   - 打开对话框
   - 输入用户信息
   - 选择角色和状态
   - 提交保存

3. **编辑**：
   - 打开对话框
   - 修改用户信息（用户名不可修改）
   - 不能修改密码（仅新建时设置）
   - 修改角色和状态

4. **禁用/启用**：
   - 快速切换用户状态
   - 确认提示

5. **删除**：
   - 删除用户记录
   - 确认提示

**表格列**：
- 用户名
- 真实姓名
- 电话
- 角色（显示中文标签）
- 状态（激活/禁用）
- 创建时间
- 操作（编辑、禁用/启用、删除）

---

## 🔑 密码管理

### 1. 密码加密

**加密方式**：MD5  
**加密工具类**：MD5Util

```java
// 注册时加密
String encryptedPassword = MD5Util.encrypt(password);

// 登录时对比
boolean matches = MD5Util.matches(inputPassword, storedPassword);
```

### 2. 密码规则

**注册密码要求**：
- 最少6位字符
- 无其他限制（可优化为强密码检查）

**修改密码**：
- 编辑用户时不能修改密码
- 仅新建用户时设置密码
- 用户自己修改密码功能未实现（可优化）

### 3. 密码安全建议

⚠️ **改进方向**：
- [ ] 升级密码加密算法（BCrypt/PBKDF2替代MD5）
- [ ] 实现"修改密码"功能
- [ ] 密码强度检查（大小写+数字+特殊字符）
- [ ] 登录失败次数限制
- [ ] 验证码防止暴力破解
- [ ] 忘记密码重置功能

---

## 🔄 业务流程

### 1. 注册流程

```
用户输入信息
    ↓
前端表单验证
    ├─ 用户名：非空 + 长度检查
    ├─ 密码：长度 ≥ 6位
    ├─ 确认密码：与密码一致
    ├─ 真实姓名：非空
    └─ 电话：非空
    ↓
发送注册请求到后端
    ↓
后端验证
    ├─ 检查用户名唯一性
    ├─ 检查密码长度
    ├─ 验证角色有效性
    └─ MD5加密密码
    ↓
创建用户记录
    ├─ 保存基本信息
    ├─ 设置状态为激活(1)
    └─ 记录创建时间
    ↓
注册成功，跳转登录页
    ↓
用户使用新账号登录
```

### 2. 登录流程

```
用户输入用户名和密码
    ↓
前端表单验证
    ├─ 用户名：非空
    └─ 密码：非空
    ↓
发送登录请求到后端
    ↓
后端处理
    ├─ 查询用户是否存在
    ├─ 检查用户状态（是否禁用）
    ├─ 验证密码（MD5对比）
    └─ 生成JWT Token
    ↓
返回登录响应
    ├─ Token
    ├─ userId
    ├─ username
    ├─ role
    └─ realName
    ↓
前端保存信息
    ├─ Token → sessionStorage
    ├─ User信息 → sessionStorage
    └─ Store更新状态
    ↓
设置请求头
    └─ Authorization: Bearer {token}
    ↓
跳转到首页（dashboard）
```

### 3. 权限验证流程

```
前端请求
    ↓
Axios拦截器添加Token
    ├─ 从sessionStorage读取Token
    └─ 添加到Authorization头
    ↓
发送请求到后端
    ↓
Spring Security过滤器
    ├─ 验证Token合法性
    ├─ 解析Token获取用户ID
    └─ 将用户信息放入UserContext
    ↓
Controller处理
    ├─ 读取UserContext获取用户信息
    ├─ 检查用户角色
    └─ 进行权限检查
    ↓
    是否有权限？
    ├─ YES → 执行业务逻辑
    └─ NO → 返回403 Forbidden
    ↓
返回响应
```

---

## 📊 主要特性

### 1. 多标签页独立登录

**问题背景**：多个标签页共享localStorage，导致登录信息相互覆盖

**解决方案**：
- 使用sessionStorage替代localStorage
- 每个标签页有独立的存储空间
- 刷新页面保持当前标签页登录状态

**实现代码**：
```javascript
// auth.js
hydrate() {
  this.token = sessionStorage.getItem(TOKEN_KEY) || ''
  const savedUser = sessionStorage.getItem(USER_KEY)
  this.user = savedUser ? JSON.parse(savedUser) : null
  this.initialized = true
}

async login(payload) {
  const data = await loginApi(payload)
  this.token = data.token
  this.user = { ...userData }
  sessionStorage.setItem(TOKEN_KEY, this.token)
  sessionStorage.setItem(USER_KEY, JSON.stringify(this.user))
}
```

### 2. 角色权限动态显示

```javascript
// 前端基于角色显示/隐藏功能
<el-button v-if="isAdmin" @click="adminOperation">
  仅管理员可见
</el-button>

// 计算属性
const isAdmin = computed(() => auth.user?.role === 'admin')
const isCaregiver = computed(() => auth.user?.role === 'caregiver')
const isResident = computed(() => auth.user?.role === 'resident')
```

### 3. 用户状态管理

- **激活状态(1)**：用户可正常登录和使用
- **禁用状态(0)**：用户无法登录，但记录保留
- **管理员可快速切换**：启用/禁用按钮

### 4. 密码安全

- MD5加密存储
- 修改用户信息时不修改密码
- 新建用户时必须设置密码

---

## ⚠️ 已知问题与改进方向

### 问题1：MD5加密算法过时
**现状**：使用MD5加密密码  
**风险**：MD5已被破解，不适合密码存储  
**改进**：使用BCrypt或PBKDF2算法

### 问题2：无密码修改功能
**现状**：用户无法自主修改密码  
**改进**：
- 添加"修改密码"功能
- 验证旧密码后设置新密码
- 登录后修改初始密码提示

### 问题3：无登录失败控制
**现状**：无限制的登录尝试  
**改进**：
- 5次失败后锁定账号15分钟
- 添加图形验证码
- 记录登录日志

### 问题4：无忘记密码功能
**现状**：忘记密码无法恢复  
**改进**：
- 邮件/短信验证重置密码
- 安全问题验证
- 身份证号码验证

### 问题5：用户管理页面缺少验证
**现状**：新增用户无法选择密码  
**改进**：
- 系统生成随机密码或固定密码
- 用户首次登录强制修改密码

### 问题6：无用户登录日志
**现状**：没有记录谁在什么时间登录  
**改进**：
- 记录登录时间、IP地址
- 记录操作日志（谁修改了什么）
- 审计追踪

### 问题7：Role字段值不一致
**现状**：
- 注册页：resident/caregiver
- 用户管理页：admin/caregiver/elderly_family/system
- 后端支持：admin/resident/caregiver/service_provider

**改进**：统一角色定义，删除未使用的角色

---

## 🧪 测试场景

### 1. 注册测试

**场景1.1：正常居民注册**
```
输入：username=resident001, password=123456, 
      realName=王大明, phone=13800138000, role=resident
期望：注册成功，跳转登录页，可以用新账号登录
```

**场景1.2：用户名已存在**
```
输入：使用已存在的用户名
期望：返回"用户名已存在"错误
```

**场景1.3：密码过短**
```
输入：password=12345（5位）
期望：表单验证失败，提示"密码至少6位"
```

### 2. 登录测试

**场景2.1：正常登录**
```
输入：username=admin, password=admin123
期望：登录成功，跳转首页，显示管理员身份
```

**场景2.2：密码错误**
```
输入：username=admin, password=wrongpassword
期望：返回"用户名或密码错误"
```

**场景2.3：用户不存在**
```
输入：username=nonexistent, password=123456
期望：返回"用户名或密码错误"
```

**场景2.4：禁用账号登录**
```
输入：使用status=0的账号登录
期望：返回"账号已禁用"或类似提示
```

### 3. 权限测试

**场景3.1：居民访问管理员功能**
```
操作：用resident角色访问用户管理页
期望：无法看到新增/删除按钮，或返回403错误
```

**场景3.2：护工查看所有费用**
```
操作：护工在费用页查看其他人的费用
期望：只能查看，不能修改
```

### 4. 多标签页测试

**场景4.1：多标签页不同账号**
```
操作：标签页1登录admin，标签页2登录resident
期望：两个标签页各自保持独立的登录状态，刷新后不变
```

---

## 📈 性能与扩展

### 1. 性能优化

**当前**：
- 用户列表分页查询
- 用户名和角色有索引
- Token使用sessionStorage

**可优化**：
- 用户信息缓存（Redis）
- 权限缓存避免每次检查
- 登录IP限制防止扫描

### 2. 功能扩展

- [ ] 第三方登录（微信、QQ、钉钉）
- [ ] 两步验证（2FA）
- [ ] 角色和权限细粒度控制（RBAC）
- [ ] 用户组管理
- [ ] 权限委托（代理权限）

---

## 总结

用户与角色管理模块是整个系统的**基础和核心**，实现了：

✅ **完整的认证机制**：注册 → 登录 → Token管理  
✅ **灵活的权限控制**：三层角色架构（admin/caregiver/resident）  
✅ **用户生命周期管理**：新建、编辑、禁用、删除  
✅ **多标签页支持**：sessionStorage独立存储  
✅ **安全基础**：MD5密码加密、权限验证  

**主要改进方向**：密码算法升级、功能完善（忘记密码、修改密码）、安全加固（失败限制、日志记录）

